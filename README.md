# svd2nim

Convert [ARM CMSIS-SVD](https://arm-software.github.io/CMSIS_5/SVD/html/index.html) files to nim register memory mappings.

This projects generates a Nim module file which can be imported to provide
access to microcontroller register peripherals. The generated Nim module
therefore serves the same purpose as CMSIS
[device.h](https://www.keil.com/pack/doc/CMSIS/Core/html/device_h_pg.html#device_h_sec)
files as generated by `SVDCONV` or provided by silicon manufacturers.

This repository was originally forked from
[Birkemosen/svd2nim](https://github.com/Birkemosen/svd2nim). However, most of
the code was rewritten to achieve the following goals:

* Conform to the CMSIS-SVD spec in order to be compatible with all Cortex-M devices,
  given that the SVD file is conforming.

* Ensure that the generated Nim code always compiles.

* Provide a high-performance yet type-safe API for low level register access.

## License

Unless specified otherwise in specific files, svd2nim is distributed under the
terms of the MIT license. See `LICENSE` file for the full terms and copyright
notice.

The SVD files under the *tests* directory are copyright of their respective
authors and used under license, as specified in each file.

## Building

Install Nim and Nimble: see https://nim-lang.org/install.html. Then,

```bash
git clone https://github.com/auxym/svd2nim
cd svd2nim
nimble install -d
nimble build
```

The svd2nim binary will be produced in the `./build` subdirectory.

## Usage

```
svd2nim - Generate Nim peripheral register APIs for ARM using CMSIS-SVD files.

  Usage:
    svd2nim [options] <SvdFile>
    svd2nim (-h | --help)
    svd2nim (-v | --version)

  Options:
    -h --help           Show this screen.
    -v --version        Show version.
    -o FILE             Specify output file. (default: ./<device_name>.nim)
    --ignorePrepend     Ignore peripheral <prependToName>
    --ignoreAppend      Ignore peripheral <appendToName>
```

## Status

svd2nim is considered to be **experimental** status. Feel free to try it, but be
warned that it could generate entire incorrect code, including code that sets
your microcontroller on fire.

## Limitations

The following CMSIS-SVD features are not implemented. Warnings will be produced
if they are encountered.  However, searching through a large repository of SVD
files (https://github.com/posborne/cmsis-svd) leads me to believe that these
features are never, or very rarely, used in the wild.

* `<field>` and `<enumeratedValues>` elements that are `derivedFrom`

* `<field>` elements containing `<dim>`, used to generate arrays or lists
  of similar elements. Note: `dim` registers, clusters and peripherals are
  commonly used and supported (except for below).

* `dim` arrays of peripherals. That is, `<peripheral>` elements with
   names containing `[%s]`. `dim` lists of peripherals, using plain `%s`,
   are supported.

## API

The Nim module generated by svd2nim tries to stay close to CMSIS conventions
when it makes sense to do so. However, Nim does not map 1:1 to C (in particular,
for marking struct members `volatile` or `const`, and for anonymous unions),
therefore the API is not identical to CMSIS C `device.h` headers. The API has
two main goals:

1. As close as possible to zero performance cost for accessing registers,
   compared to using C headers directly.

2. Use Nim's type system to provide as much safety as possible while still
   respecting goal #1.

The examples below are taken from the Nim module generated from the
`ATSAMD21G18A.svd` found under the `tests` folder of the repository.

### Peripheral Objects

For each peripheral, an `object` type is defined. Following CMSIS conventions,
`_Type` is appended to the type name. Peripheral object fields are either Cluster
objects, or Register objects. Example:

```nim
type GCLK_Type = object
  CTRL*: GCLK_CTRL_Type
  STATUS*: GCLK_STATUS_Type
  CLKCTRL*: GCLK_CLKCTRL_Type
  GENCTRL*: GCLK_GENCTRL_Type
  GENDIV*: GCLK_GENDIV_Type
```

Note that all fields are marked public.

Cluster fields are similar to Peripherals: they are "container" objects that
contain either Registers or more Clusters. Per the CMSIS-SVD spec, Clusters may
be nested arbitrarily deep.

Register fields are also `object` definitions. However, Registers contain a
single field, which is the pointer to the memory-mapped register. Example:

```nim
type GCLK_GENDIV_Type = object
  p: ptr uint32
```

Note that the pointer field is *private*. Indeed, registers are only intended to
be accessed using accessor templates described in the following section. This
allows:

* Using Nim's type system to enforce register access (read-only, write-only,
  read/write) permissions.

* Automatically inserting `volatileLoad` and `volatileStore` calls for all
  accesses.

* Convenient access to bitfields.

For each Peripheral, an instance of the object type is created and made
available, containing register pointers as defined by the base address and
offset in the SVD file. Example:

```nim
let GCLK* = GCLK_Type(
  CTRL: GCLK_CTRL_Type(p: cast[ptr uint8](0x40000c00)),
  STATUS: GCLK_STATUS_Type(p: cast[ptr uint8](0x40000c01)),
  CLKCTRL: GCLK_CLKCTRL_Type(p: cast[ptr uint16](0x40000c02)),
  GENCTRL: GCLK_GENCTRL_Type(p: cast[ptr uint32](0x40000c04)),
  GENDIV: GCLK_GENDIV_Type(p: cast[ptr uint32](0x40000c08)),
)
```

### Accessors

As noted above, Registers are only meant to be read or written using accessor
templates that are also generated. For each register object type, either a
`read` template, a `write` template, or both may be generated, depeding on
the register access permissions defined by the SVD file. Example (for a
read/write register):

```nim
template read*(reg: GCLK_GENDIV_Type): GCLK_GENDIV_Fields =
  cast[GCLK_GENDIV_Fields](volatileLoad(reg.p))

template write*(reg: GCLK_GENDIV_Type, val: GCLK_GENDIV_Fields) =
  volatileStore(reg.p, cast[uint32](val))
```

For convenience when doing a read-modify-write operation, a `modifyIt` template
is also generated for read-write registers. Similarly to the the `*it` templates
in Nim's `std/sequtils` module, `modifyIt` reads the register and stores its
value in the `it` variable. The `op` parameter passed to the template can then
modify `it`. Finally, `it` is written back to the register. Example template
code:

```nim
template modifyIt*(reg: GCLK_GENDIV_Type, op: untyped): untyped =
  block:
    var it {.inject.} = reg.read()
    op
    reg.write(it)
```

See further below for usage examples of the acccessor templates.

**IMPORTANT NOTE**: [Due to a currently open Nim
bug](https://github.com/nim-lang/Nim/issues/14623),
calling these accessors from the top-level in a module results in incorrect
codegen by the Nim compiler and C compiler errors. The workaround is simple:
ensure that all calls are made from inside a `proc`.

Note above that the type `GCLK_GENDIV_Fields` is used as a value type by the
accessors. For registers that define bitfields (SVD `field` elements), these
object types, suffixed with `_Fields`, are generated. The Nim `{.bitsize.}`
pragma is used to provide access to each bitfield.

Accessors for registers which do not define fields use plain unsigned integers
as value types (eg. `uint32` for 32-bit registers.) Registers which define a
single field that is the same size as the register are treated as if the
register did not contain fields.

Example field object definition:

```nim
type GCLK_CLKCTRL_Fields* = object
  ID* {.bitsize:6.}: 0u8 .. 63u8
  RESERVED {.bitsize:2.}: 0u8 .. 3u8
  GEN* {.bitsize:4.}: 0u8 .. 15u8
  RESERVED1 {.bitsize:2.}: 0u8 .. 3u8
  CLKEN* {.bitsize:1.}: bool
  WRTLOCK* {.bitsize:1.}: bool
```

Note: as per SVD conventions, unused bits are named `RESERVED` and marked
private. Note also the type definitions for each field:

* Fields of 1-bit size are automatically cast to `bool`.

* Larger fields are typed as subranges of the smallest unsigned integer that
  can hold the value. This provides some type safety, as attempting to write
  a larger value will generate a compile-time error.

For fields which define `enumeratedValues` in the SVD file, an `enum` type
is also generated. Example:

```nim
type GCLK_GENCTRL_SRC* {.pure.} = enum
  XOSC = 0x0,
  GCLKIN = 0x1,
  GCLKGEN1 = 0x2,
  OSCULP32K = 0x3,
  OSC32K = 0x4,
  XOSC32K = 0x5,
  OSC8M = 0x6,
  DFLL48M = 0x7,
  DPLL96M = 0x8,
```

Enums are *not* used as types in the `_Fields` objects in order to avoid
run-time errors caused by attempting to cast an invalid value on a read.
Therefore, the field value enums are intended to be used as if they were
plain `const` values, which is similar to how CMSIS C headers are structured.
`ord` can be used to convert enum values to their corresponding integer value.

A small usage example, inspired by [Thea Flowers's blog post on the SAMD21
clock system](https://blog.thea.codes/understanding-the-sam-d21-clocks/):

```nim
import atsamd21g18a

# register access is wrapped in a proc due to https://github.com/nim-lang/Nim/issues/14623
proc main() =
  # Use modifyIt to modify two fields
  NVMCTRL.CTRLB.modifyIt:
    it.RWS = 1; # Directly set integer value
    it.READMODE = NVMCTRL_CTRLB_READMODE.NO_MISS_PENALTY.ord # Use enum value with .ord

  # Write full register.
  # Note: Nim's default value for unspecified fields is 0 / false
  SYSCTRL.XOSC32K.write(SYSCTRL_XOSC32K_Fields(
    STARTUP: 0x7,
    EN32K: true,
    XTALEN: true,
  ))

  # Read bool field
  while not SYSCTRL.PCLKSR.read().XOSC32KRDY: discard

  # Read field and compare to enum value
  if GCLK.GENCTRL.read().SRC == GCLK_GENCTRL_SRC.DFLL48M.ord:
    discard

when isMainModule:
  main()
```
